# ADR: Восстановление реального потока данных для дашбордов

**Дата:** 2025-10-29  
**Статус:** Принято  
**Контекст:** Клиент Houdini на SSR обязательно ходил на `http://backend:8000/graphql`, что работало только внутри docker-compose. На локальных машинах и в нестандартных окружениях серверные запросы падали, Houdini возвращал `undefined`, и виджеты переводили это в `'0'`. Дополнительно резолвер `ConceptQuery` возвращал корутину без `await`, из‑за чего Strawberry обнулял поле `concepts`. Комбинация обоих факторов приводила к вечным нулям на `/dashboard` и в админке.

## Решение
1. Графический клиент теперь выбирает endpoint одинаково для SSR и браузера: сначала проверяет `API_BASE_URL`/`BACKEND_URL`, затем использует `VITE_GRAPHQL_ENDPOINT`. При отсутствии значения бросаем явную ошибку, чтобы конфиг не «тихо» ломался.
2. Резолвер `ConceptQuery.concepts` стал `async` и использует `await` для кешируемого сервиса. Маппинг концептов и словарей вынесен в `@staticmethod`, умеет работать как с SQLAlchemy объектами, так и с dict из Redis.
3. Добавлен интеграционный тест на лёгком SQLite, создающий минимальные сущности и проверяющий, что `concepts`, `languages`, `dictionaries` не `null`.

## Последствия
- SSR‑запросы Houdini работают в любом окружении — достаточно корректно выставить `VITE_GRAPHQL_ENDPOINT` или `BACKEND_URL`.
- Резолверы GraphQL возвращают реальные массивы даже при ответах из кеша.
- При регрессии (например, если убрать `await` или сломать маппинг) падает тест `TestDashboardGraphQL::test_dashboard_collections`.
- Для отладки добавлен `scripts/check-dashboard-stats.mjs`, который позволяет вручную выполнить запрос `GetDashboardStats` и увидеть реальные числа без запуска UI.

## Дальнейшие шаги
- Доработать backend‑тесты, чтобы покрыть другие GraphQL поля (admin stats, system stats, UI переводы).
- Подготовить mock‑слой/фикстуры для Redis, чтобы не приходилось отключать rate limit в тестах.
- Автоматизировать вызов `check-dashboard-stats.mjs` в CI (smoke после деплоя).*** End Patch

