## План организации тестирования

1. **Базовая подготовка**
   - Сформировать `.env.test` с минимальными секретами и фиктивной БД.
   - В `requirements-dev.txt` / `pyproject` закрепить `pytest`, плагины, фабрики данных.
   - Для фронтенда — зафиксировать `vitest`/`playwright` в `devDependencies`, прописать npm-скрипты `test`, `test:e2e`.

2. **Пирамиды тестирования**
   - **Unit (ядро):** сервисы, хелперы, GraphQL-резолверы — тестировать в изоляции, покрывая граничные кейсы и ошибки (pytest + fixtures, vitest для утилит).
   - **Интеграционные:** GraphQL API, REST, фоновые задачи — поднимать тестовый Postgres/Redis (docker-compose.override или pytest-docker). Проверять авторизацию, seed-данные, кеш.
   - **E2E/UI:** Playwright/Cypress сценарии входа, переходов на `/dashboard`, `/admin`, валидация отображения чисел, локалей.

3. **Данные и сидирование**
   - Создать фабрики (factory-boy/pytest-factoryboy) и захолстить базовые seed‑скрипты.
   - Для фронтенда — мок-сервер (MSW) или тестовый GraphQL сервер с заготовленными ответами.

4. **Автоматизация**
   - Настроить GitHub Actions/CI: шаги `lint → unit → integration → e2e` с отчетами (coverage, junit).
   - В nightly/job прогонять полные e2e + smoke на превью-стенде.

5. **Контроль качества**
   - Ввести правило PR: обязательный `pytest` и `npm run test` перед merge.
   - Поддерживать Codecov/Allure для отслеживания покрытия и регрессий.
   - Периодически (раз в спринт) проводить тест-ревью и обновлять чек-листы ручных сценариев.

6. **Подготовка окружений**
   - Dev: легкая база + seed, hot-reload.
   - Staging: копия боевой схемы, миграции прокатываются автоматически.
   - Prod: health-checkи и smoke после деплоя, включить наблюдаемость (Sentry, Prometheus).
